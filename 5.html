<!DOCTYPE html>
<html>
  <head>
    <title>코딩 사전</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="style.css" />
    <script src="style.js"></script>
  </head>
  <body>
    <h1><a href="index.html">Coding</a></h1>
    <div id="grid">
      <ol>
        <li><a href="1.html">HTML(frontend)</a></li>
        <li><a href="2.html">CSS(frontend)</a></li>
        <li><a href="3.html">JavaScript개념(frontend)</a></li>
        <li><a href="4.html">JavaScript(frontend)</a></li>
        <li><a href="5.html">Node.js(backend)</a></li>
        <li><a href="6.html">Database(backend)</a></li>
        <li><a href="7.html">Database-MySQL(backend)</a></li>
      </ol>

      <div id="article">
        <h2>Node.js</h2>
        <p>
          Node.js - 1.수업소개 Node.js는 자바스크립트를 이용해서 웹브라우저가
          아닌 컴퓨터 자체를 제어할 수 있다. 지금부터 우리는 자바스크립트를
          이용해서 웹페이지를 찍어내는 거대한 공장인 웹에플리케이션의 공장장이
          되어보자. Html를 코딩하는 지루한 코딩은 웹 애플리케이션에게 맡기고
          여러분은 컨텐츠를 생산하는 창의적인 일에 전념하자. Node.js - 2. 수업의
          목적 여러가지 불만족들이 이 웹사이트에 있을 수 있지만 ,우리의 관심사는
          생산성이다. 우리는 총 4개의 웹페이지이다. 그런데 우리가 가지고 있는
          웹페이지가 1억개이고, 누군가가 우리가 클릭하는 웹페이지 하나당 글 목록
          숫자를 없에라고 수정을 원한다면 우리는 1억개는 바꿔야한다. ol테그를
          전부 ul테그로 바꿔야한다. 바로 이러한 상황에서 우리를 구원해주는 것이
          node.js이다 수업이 끝나면 이걸 이해해야한다. 어디에만 집중해야하는가?
          Main.js의 파일은 자바스크립트의 언어의 문법이다. 저기의 글 목록이
          1억개라고 했을 때, node.js와 같은 기술을 사용하지 않으면 파일을
          하나하나 1억개를 고쳐야하지만 그러나 node.js를 사용하면 우리는 여기
          template.js라고 하는 저 파일 안에 우리가 알고 있는 html코드가 있는
          것을 볼 수 있다. 그리고 저기의 ul부분을 ol로 바꾸어만 주면 보시는
          것처럼 여기있는 코드가 ol코드로 바뀐다, 즉, node.js와 같은 기술을
          사용하면 단 하나의 파일 template.js라고 하는 파일 안에 html의 코드가
          들어가 있고 여러분은 그 코드만 바꾸면 지금까지 여러분이 만든 1억개의
          웹페이지의 내용을 한번에 시간이 걸리지 않고 바꿀 수 있는 폭발적인 힘을
          갖는다. 이것이 가능한 이유는 우리가 웹페이지를 1억개를 저장한 것이
          아니라, 사용자가 어떤 페이지를 요청할때마다, node.js와 같은 기술로 그
          순간순간에 웹페이지를 프로그래밍적으로 생성해내기 때문에 가능하다.
          그리고 node.js와 같은 기술을 이용하기 전에는 사용자로부터 우리가
          컨텐츠를 받을 수 있는 방법이 없었기 때문에, 만약에 사용자의 참여를
          유도하려면 우리가 사용자에게 이메일과 같은 방법으로 글을 받은다음에,
          3.4.5.6.7…..html의 파일을 직접 만들어야 했다. 즉, 사용자의 참여가 제한
          되었다., 하지만 우리가 node.js로 만들 웹 애플리케이션에는 create버튼이
          있고 글을 쓰고 누르면 data 파일안에 파일이 하나 생겼다. 그리고
          글목록에 항목이 추가 되었다. 수정할 수도 있다. delete버튼을 부르면
          삭제가 된다. 즉, 우리는 자바스크립트를 이용하고있는 node.js를 이용해서
          우리 웹사이트로 방문하는 사용자에게 컨텐츠에 대한 읽기뿐만 아니라
          CRUD라고 하는 4가지의 작업을 모두 웹을통해서 할 수 있도록 제공할 수
          있다. 바로 이런 것들이 가능하면서 사용자들이 자신의 컨텐츠를 웹에 올릴
          수 있었고 인터넷과 웹이 폭발적으로 발전했고 그 중간에 node.js가 있고
          경쟁 관계로는 ruby on rails가 있다. Nodejs - 3.설치 우리는 웹
          브라우저에 익숙하고 그 위에 돌아가는 웹 에플리케이션을 만들게 된다.
          그거를 만들기 위해서는 웹브라우저가 가지고 있는 여러기능 중에서 예를
          들면 제목을 표시하거나 링크를 표시하는 이러한 기능중에서 우리가
          만들고자 하는 웹 애플리케이션에 필요한 기능을 html이라는 컴퓨터 언어를
          통해서 웹 에플리케이션을 만들게 된다. Node,js마찬가지 이다., 우리는
          노드를 설치해야 하는데, 그거를 node.js runtime라고 부르는데,
          우리는node.js runtime 프로그램에서 마치 우리가 웹브라우저에서 그랬던
          것처럼 자바스크립트라는 컴퓨터언어를 통해서 node.js runtime이 가지고
          있는 여러 기능들 중에서 우리가 필요한 것들을 호출하는 것을 통해서
          node,js 애플리케이션을 만들 수 있게 된 것이다. 지금부터 우리가 필요한
          것은 node.js runtime을 각자 컴퓨터에 설치하는 것이고 그 다음에 우리는
          자바스크립트라는 컴퓨터 언어라는 것을 통해서 node.js 런타임을
          실행시키는 걸로 우리가 만들고자 하는 노드 애플리케이션을 어떻게 만들게
          되는 것인가라는 것을 공부하게 될 것이다. 인제 각자 운영체제 별로
          node.js 설치법을 가르쳐준다. 여기서 자바스크립트라는 컴퓨터 언어에
          따라서 node.js가 갖고 있는 console.log라는 기능을 이용해서 출력가능
          여기서 나올때는 ctrl + cc 이 코드가 많고 자주 사용되고 내가 아닌 다른
          사람이 실행하고 싶게 하다면 저렇게 직접 코드를 작성해서 실행할때마다
          타이핑 하는 것은 쉽지 않고 어떤 파일을 만들어서 그 파일에 실행되었으면
          하는 코드를 넣고 node.js에게 node야 저 파일 안에 있는 내용을 실행시켜
          라고하면 된다. 이건 무슨 뜻이냐면 우리가 node.js 런타임에게
          helloworld.js라는 파일 안에 있는 코드를 실행시켜라는 뜻이다. 2가 뜬다.
          그 다음에는 똑같다. Node.js - 4.공부방법 Node.js 수업의 각 제목에는
          JavaScript, Node.js, App과 같은 접두사가 붙어 있습니다. JavaScript는
          자바스크립트의 기본 문법, Node.js는 Node.js의 사용법, App은
          웹애플리케이션을 만드는 방법을 담고 있습니다. 이미 알고 있는 내용은
          생략할 수 있도록 수업을 제작했습니다. 아는 내용은 생략하는 것을 통해서
          시간을 절약하세요. 우리의 목표는 node.js로 만들어진 웹 애플리케이션을
          만드는 것이다. 바로 그 목표를 향해서 나아갈 것이고 그걸 하기 위해서는
          뭐가 팔요하냐면 각각의 스텝마다 node.js가 가지고 있는 기능을 실행시킬
          것이다. Node.js기능을 실행시키기 위한 조작장치는 자바스크립트라는
          컴퓨터 언어이다. 그래서 순서한 여러분에게 필요한 Js의 문법을 적당히
          알려주고 그다음에는 JS문법을 통해서 node.js가 갖고있는 우리에게 필요한
          기능들을 적당히 배우고 그러면 그 node.js의 기능을 이용해서
          애플리케이션을 하나씩 하나씩 완성할 것이다. 이 과정을 반복하면서
          완성할 것이다. 자바스크립트가 익숙하다면 node.js기능만보고 node.js가
          익숙하다면 node.js는 빼고 node.js로 웹 에플리케이션을 어떻게 만드는지
          집중해라 Node.js - 5.Node.js로 웹서버 만들기 Node.js는 웹서버 기능을
          가지고 있습니다. 이런 특성을 이용해서 컨텐츠를 프로그래밍적으로 생산할
          수 있게 됩니다. 여기서는 Node.js를 웹서버로 구동하는 방법을
          살펴보겠습니다. 우리 수업에서 가장 중요한 큰 틀을 얘기할 것이다.
          Node.js도 이 손바닥 위에 있다. 웹 브라우저는 웹서버에게 정보를
          요청하고 웹서버는 정보를 건내준다. Web1의 웹서버는 아파치가 있다,
          그러면 우리가 지금부터 node.js는 아파치와 똑같이 웹서버로도 사용될 수
          있다. 왜냐하면 웹서버 기능을 내장하고 있다. 바로 그런 특성을 이용하면
          바로 아파치 웹서버는 할 수 없는 일을 할 수 있다. 자 그걸 하기 위한
          코드를 살펴보자. 그리고 node.js로 웹서버를 만들어보자. 웹프로젝트에
          새로운 파일을 만들고 위에 붙여넣자. Localhost:3000했을 때 홈페이지가
          나오면 잘 된 것이다,. 컨트롤 c라면 끄는 것이다. 그러면
          localhost:3000은 접속이 안될 것이다. 즉, node.js는 웹서버로서 동작하고
          있다. 지금 저게 뜨는 이유는 이 코드가 console.log(__dirname + url);
          이다. 이 실습파일의 main.js가 위치하고 있는 디렉토리이고 요기 있는
          /2.html이 나오는 것은 요 접근할 때, 사용자가 요청할 때 /2.html이
          전달되었기 때문이다. 자바스크립트(다른 웹사이트)를 선택하면 바뀐다.
          즉, 사용자가 요청할때마다 접근할때마다 우리는 자바스크립트를 통해서
          요렇게 생긴 코드를 이용해서 우리가 읽어들여야 할 파일을 만들게 되는
          것이다. readFileSync그것을 읽는다 파일로부터! 이렇게 생긴 어떤 명령에
          에다가 그 값을 주면 저 명령어가 node.js의 기능이다. Node.js가 그
          경로에 해당되는 파일을 읽어서 그 값을 가져오는 것이다. 그리고 그것을
          response.end 괄호 안에다가 위치시키게 되는 것이다. end 안에를 바꾸고
          서버를 다시 가동시키면 이렇게 된다. 그리고 이거를 1로하면 이렇게 된다.
          즉, node.js는 여기있는 요만큼에다가 앞으로 우리가 여러가지 것들을
          배워서 어떤 코드를 넣느냐에 따라서 사용자에게 전송하는 데이터가
          바뀐다! 이것이 아파치와 같은 웹서버는 할 수 없고 node.js 나 php나 또는
          파이썬의 django와 같은 것들은 할 수 있는 일이다. 즉, 프로그래밍 적으로
          사용자에게 전송할 데이터를 생성한다. 라는 것이 node.js가 가지고 있는
          힘이다. Node.js - 9.URL의 이해 URL에 포함된 쿼리 스트링을 해석해서
          이용하는 방법을 살펴봅니다. 우리의 목표는 JS 를 이용해서 node.js가
          가지고 있는 기능을 호출하면 우리가 웹 에플리케이션을 node.js로 만들 수
          있다. 이제 쓱 node.js로 넘어가서 웹 에플리케이션을 구현하는 아주
          중요한 테크닉을 볼 것이다. 지금 저 각각의 링크는 각각의 정적인
          파일들을 가져오고 있다. 1억개의 링크라면 우리는 1억개의 정적인
          파일들을 가지고 있어야 한다. 이걸 보면 똑 같은 파일을 요청해서 받은
          정보인데, 근데 뒤에있는 p의 값이 다르다. 즉, 같은 파일이지만, 저기있는
          저 값을 달리하는 것을 통해서 viewtopic.php 라는, 우리는 php 모르지만,
          php 애플리케이션이 클라이언트에게 웹브라우저에게 서로 다른 페이지를
          만들어서 보내고 있는 것이다. 우리도 할 수 있다. 그것을 하기 위해서는
          url의 형식에 대해서 자세히 알아야한다. 저것은 프로토콜, 통신규칙이라고
          한다. 즉, 사용자가 서버에 접속할 때, 어떤 방식으로 통신할 것인가에
          대한 부분이다. 웹브라우저와 웹서버가 데이터를 주고 받기 위해서 만든
          통신 규칙이다. 만약 FTP쓴다면 저기에 이게 있을 것이다. 이것은
          도메인이라고도 하고 호스트라고도 한다. 호스트라는 것은 인터넷에
          접속되어 있는 각각의 컴퓨터를 호스트라고 한다. 즉, opentutirials속
          org는 어떤 특정한 인터넷에 연결되어 있는 컴퓨터를 가리키는 주소이다.
          저거는 포트번호이다. 생각해봐라 한대의 컴퓨터안에 여러대의 서버가 있을
          수 있다. 그러면 클라이언트가 접속했을 때, 그중에 어떤 서버와
          통신할지가 애매하다. 그래서 접속할 때 3000이리고 하면 3000번 포트에
          연결되어 있는 서버와 통신하는 것이다. Main.js에서 여기에 3000이라고
          했고 위에 3000이라고 한 것은 “3000번 포트에 우리의 node.js웹서버를
          실행시킨 것이기에 접속할때는 저렇게 3000이라고 명시하는 것입니다.
          만약에 우리가 80이라하면 왼쪽3000은 로드가 안될 것이다. 다만 3000을
          지우면 80은 안적어도 된다. 왜냐하면 웹 서버는 굉장히 유명한 서버이기
          때문에 웹서버는 80번포트를 쓴다고 전세계 적으로 약속되어 있기 때문에,
          우리가 http를 통해서 접속했다? 그러면 웹서버에 접속한 것이다. 즉,
          포트번호를 생략하면 80으로 접속하게 되는 것이다. 디폴트가 30이다.
          이것은 path이다. 그 컴퓨터 안에 있는 어떤 디렉토리에 어떤 파일인지를
          가리킵니다. 그 다음에 나오는 이거가 바로 우리 수업의 주인공이다. 즉,
          여기있는 쿼리스트링의 값을 변경하면 이거 앞에 있는, 즉 우리가
          웹서버에게 어떤 데이터를 전달할 수 있어요. 내가 읽고 싶은 정보는
          html이고 12page이다 이런 식으로요. 그리고 쿼리스트링의 시작은 ?로
          시작하도록 약속되어 있다. 그리고 값과 값은 &를 쓰기로 약속했고 값의
          이름과 값은 =로 쓰기로 약속했다. 다음시간에는 쿼리스트링의 값에 따라서
          node.js를 통해 만든 웹서버가 사용자에게 동적으로 생성한 정보를
          전송하는 방법을 소개할 것이다. Node.js - 10.URL을 통해서 입력된 값
          사용하기 실습하실 때 url 뒤에 ?id= 의 값을 직접 입력해주셔야 오류가
          발생하지 않습니다. 본격적으로 웹 에플리케이션을 만들어 봅시다.
          저기있는 주소로 사용자가 우리의 웹에플리케이션으로 접속했을 때, 우리가
          하고싶은 것은 저 id값이 무엇이냐에 따라서 사용자에게 적당한 컨텐츠를
          보여주는 것이다. 저기 아이디에 해당하는 부분을 쿼리 스트링이라고 한다.
          지금부터 쿼리스트링에 따라서 다른 정보를 보여주는 것을 해볼 것이다.
          main.js 이 파일을 어떻게 바꾸면 사용자가 위에 주소처럼 이렇게
          자바스크립트라는 값으로 접속했을 때, 저 쿼리스트링에 있는 값을
          화면(제목)에 출력하고 또는 만약에 저부분이 CSS라면 화면에 css가
          제목부분에 출력되게 하려면 어떻게 하는지 살펴볼 것이다. 코드가
          똑똑하지 못해서 바꾼 것이다. 이제 우리이게 필요한 것은 여기에 있는
          쿼리스트링을, 우리 main.js라는 node.js 애플리케이션에서, 저 HTML부분의
          값을, 알아내는 방법을 알아야한다. 저기 HTML의 값은 request.url에게
          반영이 된다. Request.url이 쿼리 스트링에 대한 정보를 담고 있다.
          Console.log로 확인해보았다. /?d=HTML 이 url이라는 변수의 값이다. 위에
          주소가 localhost:3000/?d=CSS가 되었다면 콘솔의 저 부분은 /?id=CSS로
          출력될 것이다. 즉 우리는 url이라는 변수 안에 들어있는 값을 추출하는
          것을 통해서 우리가 원하는 값을 얻어낼 수 있다. 그걸 하기 위해서는
          우리가 url부터 url을 분석해서 데이터를 추출해야한다. 검색을 통해서
          알아보자. Nodejs url parse query string: 노드js부터 url을 분석한다.
          우리가 지금 알고 싶은 것은 query string Request.url을 넣으면 Quert
          data가 나오고 그 quert data에서 .name을 하면 querystring에서 여기 있는
          것처럼 name의 값이 Tom이라는 것을 알 수 있다. 그럼 이제 한참을 저거를
          분석하고 오랜시간 동안 이것 저것을 찾아보면서 수단 과 방법을 가리지
          않고 문제를 해결하는 것이다. 보는 것과 같이 쿼리 스트링이 바로
          나타나진 않는다. 그래서 쿼리 스트링을 알아야한다. 저거를 오른쪽에 붙여
          넣는다. Require 이라는 것은 요구한다라는 뜻이다. 어떤거를? 우리가
          만들고 있는 웹 애플리케이션은 url이라고 하는 걸, fs 그리고 http라는
          것을 요구한다는 뜻이다. 자 여기서 얘기하는 url(fs http)는 모듈이라는
          것이다. Node.js가 갖고 있는 수많은 기능들을 비슷한 요건끼리 그룹핑
          해논 것을 모듈이라고 한다. 즉, 우리는 url이라고 하는 모듈을 사용할
          것이라고 node.js에게 알려주는 것이다. 앞으로 url이라는 node는
          url이라고 하는 변수를 통해서 사용할 것이다 라고 하는 것이다. 문제가
          있다. 우리가 url의 값을 가져오는 코드(request.url)에서 url의 값을 썼고
          url모듈도 url을 쓰면 안되잖아요. 그러면 선택을 해야한다. 코드를 줄줄이
          바꾸면 된다. 그러면 이제 url은 모듈 url을 가리키는 것이다. 자 그
          다음에 임의로 id?=HTML을 넣고 로드 하였더니 오류가 뜨고 페이지가
          안뜬다. 저렇게 화면에 출력된다는 것은 쿼리 데이터라고 하는 저 변수에
          담겨있는 값이 객체라는 값이다. Console.log(queryData.id) 하면 HTML 이
          뜬다. 만약에 저기에 id값이 name라면 우리는 queryData.name 으로 하는
          것을 통해서 똑 같은 결과를 얻을 것이다. 우리가 여기에 id값을
          얻어내었다,. 저부분은 사용자가 접속한 url에 따라서 1.html 2.html 과
          같은 파일들을 읽어주는 코드가 바로 지금 선택한 부분이다. 저거를
          지워버리고 실행해보면 보시다 싶이 HTML이 화면에 출력된다. Undefinded는
          나올 수도 있고 아닐 수도 있다. 무시해라. 주소의 id의 value값을 CSS로
          바꾸면 화면에 CSS로 잘 나온다. 이렇게 해서 우리가 쿼리 스트링에 따라서
          다른 정보를 출력하는 웹 에플리케이션을 만들었다. 다음시간에 재대로된
          정보를 출력하도록 해봅시다. 다음시간에 정리를 하면 cmd창에서 서버가
          돌아가고 있는데(node.js로 짠 main.js가) 클라이언트가 브라우저 상에서
          주소:포트번호/?객체이름=값 을 주면, main.js 즉, 서버가 이 입력값을
          받아서 거기에 해당하는 값을 출력하는 거군요. end() 안에 객체 아이디에
          해당하는 value값을 출력하는거로 말이죠.
          https://backback.tistory.com/276 Node.js – 클라이언트로 응답을 보내는
          방식 (참고해라) http모듈에서 createServer로 서버를 생성한다.
          listen으로 요청하면 createServer 함수가 콜백된다. request값과 response
          값이 정해진다. Node.js-11.App 제작-동적인 웹페이지 만들기 이전 시간에
          쿼리 스트링에 따라 다르게 동작하는 node.js 애플리케이션을 만들어
          보았다. 굉장히 중요한 것을 했다. 그러면 이제 쿼리 스트링에 따라서 다른
          완성된 웹페이지를 표현하고 싶지 않냐? 해봅시다. 지금 루트로 들어
          갔거든요? 최상위 경로로 접속하면 _url 이/가 된다. 이렇게 해서 우리가
          웹 애플리케이션에서 가장 중요한 부분, 즉 정보를 다이나믹하게
          프로그래밍적으로 생성한다는 정말 중요한 것을 해 내었다. 만약 역기서
          ol테그를 ul로 바꾸면 모든 웹페이지 1억개가 모두 목록이 동시에 바뀌는
          폭발적인 효과가 있다. 다음 도약지점을 생각해보자. 자 우리는 제목
          부분은 동적으로 바뀌는 것에 성공하였지만, 본문은 정적이다. 여기있는
          본문은 파일에 본문만 저장했다가, 사용자의 요청이 들어왔을 때, 그
          요청에 해당되는 파일에 본문만을 읽어서 이곳에 가져다 놀 수 있다면,
          우리는 각각의 페이지가 html코드 전체를 가지고 있는 것이 아니라, 이
          중에서 딱 본문만을 가지고 있는 파일에다가 데이터를 저장하는 걸 할 수
          있다. 다음시간에는 이런 것들을 위한 것들을 차근차근 밣아나가자.
          Node.js-12.Node.js의 파일 읽기 기능 Node.js에서 파일을 읽는 방법을
          알려드립니다. 노드 js에서 파일을 다루는 방법을 볼 것이다. 정보
          시스템의 핵심적인 개념이 CRUD이다. 바로 4가지의 처리가 정보를 다루는
          핵심적인 처리방법이다. 그 중에서 가장 중요한 것은 C이다 c가 없으면
          rud는 없다. R는 c에 필적할만큼 중요하다. 읽지 않을거면 생성해서
          뭐하겠어요? 그래서 보통 정보시스템에서 가장 첫번쨰로 알아봐야 할 것은
          그게 파일이건 데이터베이스건 이 바닥에서 생성과 읽기는 어떻게 하는
          가를 파악하는 것이다. 그걸 할줄 아는 것은 그 바닥의 50%나 아는 것이나
          다름 없다. 그걸 파악하면 10분도 걸리지 않는다. 많은 시스템들이 수정이
          가능하고 삭제가 가능해야 한다. 만약 수정과 삭제를 알면 그 바닥의 75%나
          아는 것이나 다름 없다. 그러면 나머지 25%에 해당되는 것은 엄청난
          에너지와 노력을 들여서 수련을 해야한다. 그래서 CRUD라는 것을
          이번수업에서는 중심적인 주제로 채택하고 있다. 이번시간에 우리가 살펴볼
          것은 파일을 어떻게 하면 node.js로 읽을 수 있는 가를 살펴볼 것이고 그
          다음에 뒤에서 생성,수정,삭제를 node.js에서 하는 방법을 차차로 살펴볼
          것이다. 여러분이 노드.js로 파일을 읽고 싶다면 검색을 통해서 알아내야
          한다. 노드 js의 공식문서를 타고 들어가면 여기에 보시면 쭉, 노드js가
          제공하는 모듈들이 나온다. 모듈이 무엇이냐? 기본적으로 제공하는
          기능들을 그룹핑해논 각각의 그룹들을 모듈이라고 한다. 여기서
          filesystem을 클릭해보면 아까 우리가 검색을 한 것과 똑 같은 페이지로
          간다. 이름을 쭉 보면은 이름 안에 많은 것들이 암시되어 있다. Fs는
          파일시스템의 약자이다. 예제가 있네? 예제를 쓱 보고, 잘 이해가 안가면
          여기있는 각각의 요소들에 대한 설명을 좀 보셔라. 그래도 이해가 안되면
          검색하고 질문하고 수단과 방법을 가리지 않고 쟤를 사용하는 방법을
          익히셔야 합니다. 이런 것에 익숙해져야 한다. 그러면 여기에서 이제
          어떻게 하면 되는가라는 부분인데, 우리가 지금 필요로 하는 것은
          node.js의 시스템중에서 파일 시스템이다. 어떻게 호출하면 되냐면 Const는
          상수라는 뜻인데 var라고 적어라. 그러면 fs라는 변수를 통해서 노드.js의
          모듈인 파일시스템을 다루게 된 것이다. 그리고 그 중에서 우리가 필요한
          것은 여기는 딱 보니까 우리가 읽고 싶은 파일을 적네? 왼쪽의 방법은 최신
          Js의 스페게 코드니까 좀 옛날 방식을 쓰자. 아직은 이해 못해도 괜찮다.
          우리의 목표는 이해하는 것이 아닌 익숙해 지는 것이다. 그리고 저기
          왼쪽에 data라는 것을 console log를 하면 뭐가 된다라는 뜻이다. 그리고
          node nodejs/filelead.js를 실행시키면 결과값은 실행이 안된다. 왜냐하면
          지금 filelead.js는 sample.txt와 같은 디렉토리에 있지만, 우리의 node는
          현재 nodejs폴더 상위 디렉토리에서 실행된 것이다. 그렇기 떄문에 우리가
          여기서 실행을 하면 이 디렉토리에 있는 sample.txt를 찾게 되는데, 없기
          때문에 이런 결과가 나온 것이다. 어떻게 하면 되냐? 노드를 실행하는
          디렉토리에서 sample.txt를 찾을 수 있어야한다. 저렇게 숫자가 나오는
          이유는 우리가 저거를 처리할 수 없는 형태로 출력해서 그런데, Utf8하고
          실행을 시키면 원하는 결과가 잘 나온다. 이번시간에는 우리가 파일을 읽는
          방법을 살펴보았다. Node.js-13.App 제작- 파일을 이용해 본문 구현
          이제부터 지금까지 배운 것을 총동원해서 쿼리스트링 값에 따라서 본문이
          변경되는 웹 애플리케이션을 만들어 볼 것이다. 배운 것을 서둘러서
          써보아야 한다. data라는 폴더를 만들고 여기에 이제
          html,css,jacsscript의 본문만을 컴팩트하게 집어넣을 것이다. 이제 html의
          코드는 없는 순수하게 본문만 가지고 있는 data디렉토리에 넣었다. 그러면
          이제 main.js에서 요기 이부분 있잖아요? 본문 아직 구현이 안끝난!
          저부분은 우리가 사용자의 쿼리스트링의 값에 따라서 data디렉토리에 있는
          적당한 파일을 읽은다음에 제가 강조표시한 저 곳에다가 치환해주면 될
          것이다. 가져다 주면 될 것이다. 우리가 이전에 배웠던 것을 잘 생각해보면
          뭘하면 되겠어요? 그리고 본문 내용을 이 안쪽에다가 넣으셔야 한다.
          여렇게요. 저기에 이미지 태그는 지웠다. 그리고 노드js를 껐다키지 않아도
          리로드하면 바로반영이 된다. 왜냐 페이지가 열릴때마다 html파일의 내용을
          읽어서 화면의 내용을 출력해주기 때문이다. Main.js의 내용이 바뀌면
          현재로서는 껐다키셔야 한다. 이 데이터 안에 있는 내용은 내용을 읽기
          때문에, 걔는 내용이 수정될때마다 실시간으로 바뀐다. 이렇게 해서
          지금까지 우리는 파일을 읽는 을 투입해서 다이나믹한 웹페이지를 생성하는
          것까지 하였다. Node.js-18.NodeJS-콘솔에서의 입력값 검은색 원을
          프로그램이라고 생각해라. 이 프로그램이라는 것은 크게 입력에 대해서 저
          프로그램이 정보를 처리한 후에 출력하는 기계이다. 그래서 저 입력을
          부르는 여러가지 표현이 있는데 라고 부른다. 파라미터는 입력되는 정보의
          형식이 있을 것이고 이것을 파라미터라고 한다. Argument는 그 형식에 맞게
          실제로 입력한 값이다. 물론 구분을 못하고 혼란스럽게 사용해도 되고
          함수를 들어갈 때 다시 알려준다. 아무튼 우리가 만든 프로그램은 인풋과
          아웃풋이 있는데, 이것을 줄여서 io라고 한다. 그리고 우리가 이
          프로그램을 만들 때, 이미 웹 애플리케이션에서 url을 통해서 입력값을
          주고 그 결과를 이제 html로 output 출력을 했었잖아여? 또 콘솔에서는
          실행을 할 때, 콘솔화면에서 출력을 했다. 또는 프린트에서 출력할 수도
          또는 파일에 저장하는 것도 아웃풋이라고 할 수 있습니다. 즉, 인풋도
          여러가지 종류가 있고 아웃풋도 여러가지 종류가 있을 수 있는데, 우리가
          이번시간에 살펴볼 인풋은 콘솔에서 여러분이 명령을 실행할 때, 입력값을
          주는 방법을 살펴볼 것이다. 그리고 극것에 따라서 저 프로그램이 내부에서
          조건문을 이용해서 입력값이 무엇이냐에 따라서 다르게 동작해서 다른
          아웃풋을 출력하는 프로그램을 만들 것이다. 실용성은 없다. 어떻게
          arguments를 커맨드 라인에서 node.js한테 넣을 것이냐? 이거를 한번
          써보자 한번 붙여놓고 써보니까 저 args라는 변수 안에 저렇게 생긴 배열이
          있다. 첫번째 자리에는 노드js가 어떤 정보를 주고 있냐면 node.js의
          런타임!이 어디에 위치하고 있는 지를 알려주고 있다 그리고 두번째
          자리에는 우리가 실행시킨 이 파일의 경로를 주고 있다. 그리고 세번째
          자리에 우리가 입력한 입력값을 주고 있다. 즉, node.jS는 이 뒤에
          들어오는 입력값들을 세번째 정보부터 입력값을 주도록 약속!되어 있다.
          그리고 우리가 여기 있는 이 3번째 값을 가져오려면 컴퓨터는 숫자를 0부터
          카운팅하기 때문에 eging은 2번째 자리이다. Args[2]로 수정하고 다시
          실행하였더닌 egoing이 되었다. 즉 왼쪽 값이 오른쪽 값이 된 것이다. 자
          이점을 착안해서 이제 뭘 할거냐면 (node syntax/conditional.js 1) 1로
          했을 때, if문의 false가 true가 되면서 1이 아닌 다른 값이 왔을 때,
          if문이 false가 되면서 C2가 실행되도록 하는 애플리케이션을 만들 것이다.
          저기 아래 그냥 1이라고 하는 것은 숫자가 아니라 문자이다. 즉 우리는
          전혀 실용적이지는 않지만, 이 프로그래밍이라는 것에서 이 제어문이라는,
          그중에서 하나인 조건문을 통해서, 이 프로그램으로 들어오는 입력값이
          무엇이냐에 따라서 조건문이 다르게 동작해서 하나의 프로그램이 여러 개의
          얼굴을 갖게하는, 하나의 프로그램이 여러가지 동작을 할 수 있도록 하는
          훨씬 더 확장성 높은 똑똑한 프로그램을 만들 수 있게 된 것이다.
          Node.js-19.1.App 제작-Not found 구현 자 이제 우리 조건문을 도입해서
          우리 애플리케이션을 좀 더 정교하고 쓸만한 것으로 만들자. if문없엤다.
          지금부터 할려고 하는 것은 사용자가 쿼리스트링이 없는 홈(WEB버튼)으로
          들어오게 되면, wlcome페이지를 출력할 것이고 사용자가 저기에 목록을
          클릭해서 쿼리스트링이 있는 id값이 있는 주소로 접속하면 그 id값에
          해당되는 파일을 데이터 디렉토리를 찾아서 웹페이지를 생성할 것이다.
          그리고 그 외에 주소로 들어 왔을 때, 예를 들면
          localhost:3000/favion.icen 존재하지 않는 이런 다른 경로로 들어
          왔을때는 파일을 찾을 수 없다는 메시지를 사용자에게 줄 것이다. 이
          기능을 만들 것이다. 그것을 하기 위해서 제일 먼저 할 것은 사용자가
          루트로 접근했는가? 아닌가를 판별해야한다. 루트라고 하면 저기 주소 뒤에
          path정보가 붙지 않는 상태! 지금 현재의 상태가 루트상태이다. 그러면
          저기 있는 저 코드는 주어진url 정보를 분석해서 이런식으로 정보를 우리가
          쉽게 쓸 수 있도록 도와준다. 물론 문법을 모르기 때문에 이해가 쉽지
          않다. 즉 path는 여기있는 쿼리스트링이 포함이 되어있고 pathname은
          쿼리스트링이 실제로 주소에 있다고 하더라도 쿼리 스트링이 아닌, 쿼리
          스트링을 제외한 path만을 보여주는 차이점이 있다. 저 pathname을 가지고,
          만약에 지금 접속한 접속이 루트라면, 즉, path가 없는 경로로 접속했다면,
          여기 있는 코드를 실행하고 옮기기. 그 외의 경로로 접속했다면 일단
          이렇게 적는다. 자 writeHead에서 200이라고 하는 것은, 자 생각해 보아라.
          웹브라우저가 웹서버에 접속했을 때, 웹서버가 응답을 할거 아니냐? 그때,
          웹서버와 웹브라우저 사이에서 잘 되었는지 에러가 있는지 아니면 이
          페이지가 다른 데로 이사를 갔는지 이러한 중요한 정보를 기계와 기계가
          서로 통신하기 위한 아주 간결한 약속이 필요하다. 그래서 200이라고 하는
          숫자를 서버가 브라우저에게 주면 파일을 성공적으로 전송했다!라는
          뜻이다. 파일을 찾을 수 없는 경우에는 웹서버는 404라고하는 약속된
          번호를 돌려준다. 그리고 여기는 파일을 찾을 수 없다는 뜻에서 Not found.
          홈으로 갔을때는 아직 구현이 덜 되어있다. 각각의 페이지로 갔을때는
          정상적으로 페이지가 잘 표시된다. Node.js-19.2.App 제작-홈페이지 구현
          자 이번시간에 홈부분이 처리가 안끝났다. 홈을 갔더니 Undefined는
          정의되어 있지 않다는 뜻이고, 즉, 제목과 본문이 없다라는 뜻이다. 그리고
          각각의 페이지로 갔을 때는 잘 동작한다. 그 이유는 아직 홈에 한 처리가
          되어있지 않기 때문인데, 저기 오른쪽에pathname=/라는 뜻은 우리가 홈에
          갔을때도 pathname은 /라는 뜻이다. 페이지로 갔을때도 특별한 경로가
          붙어있지 않기 때문에 pathname=/이다. 즉, pathname 이 값을 통해서는
          홈과 각각의 페이지를 구분할 수 없다. 그러면 우리가 반복문을 중첩해서
          사용하는 것을 통해서 이 두개를 구분할 수 있다. 그때 사용하는 구분
          기준은 queryData.id이다. 쿼리스트링이 지금처럼 있다면, 아이디는 어떤
          값을 갖고 있을 것이고 지금처럼 쿼리스트링이 존재하지 않는다면,
          queryData.id값은 존재하지 않을 것이다. Undefined가 뜰 것이다. 만약
          쿼리데이타.아이디가 정의 되지 않은 데이터라면, 즉,
          undefined라면(이것은 약속이다). 어떠한 없는 값을 여러분이 호출하려고
          했을 때, 자바스크립트는 그것을 undefined라고 부른다. 즉, 저기있는
          아이디 값과 undefined의 값이 같다면 홈!이라는 뜻이다. 이렇게하면 저기
          있는 코드가 실행될 때, 저기 있는 title은 welcome, description은 hello
          node.js가 저기에 포함이 될 것이다. 그 상태로 출력이 될 것이고요, 그
          다음에 queryData.id가 undefined가 아니라면, 즉, 값이 있다면, 다른
          코드가 실행되게 하면 된다. 그리고 제목표시부분을 저렇게 read파일
          안에다가 넣고 위에 있는 타이틀이 너무 동떨어져 있으므로 여기에 넣는다.
          Console.log 쓸때없는거 지우기. 자 이렇게 해서 조건문을 투입해서 조건에
          따라서 다르게 동작하는 어플리케이션을 우리가 현실에서는 어떻게 만드는
          가를 여러분들이 음미할 수 있는 시간을 가져보았다. 저부분은 없어도
          된다. 읽어올 파일자체가 없기 때문이다. 뒤쪽 수업에서 지울 것이니 굳이
          지우지 말고 냅두어도 된다. Node.js-23.Node.js에서 파일목록 알아내기
          이번시간에는 node.js 기능을 이용해서 웹 애플리케이션을 보다 완성도
          있게 만들기 위해서 필요한 전단계 , 즉 문제의 발견을 해보자. 우리의
          애플리케이션은 몇가지 문제점이 있다. 저기에 데이터를 추가하면 그때마다
          저기 있는 글목록을 편집해야하고 아래있는 것도(2번 중복) 해야한다. 만약
          이 리스트의 수정과 삭제 추가가 빈번하다면 굉장히 고통스러울 것이다.
          우리가 고통스러운 상황에 놓여있다면 이거를 어떻게 기계한테 맡길
          것이냐를 모색할 것이다. 그 생각의 첫번째 단추는 이 데이터 디렉토리의
          파일이 추가되거나 수정되거나 삭제되었을 때, 그것을 어떻게 node.js를
          통해서 알아낼 수 있는가 라는 것이다. Error도 변수이름이고 filelist도
          변수이름이다. 중요한 것은 자리이지 이름은 변경해도 상관없다. 안된다.
          현재 저는 web2-nodejs디렉토리에서 nodejs/readdir.js를 실행하는 것이다.
          Readdir.js가 있는 위치가 아니라, 제가 실행하는 위치를 기준으로 해서
          data라는 디렉토리의 경로를 저기에 적어줘야 한다. 저런식으로 말이다.
          data와 ./data는 같은 뜻이다. ./의 뜻은 현재 디렉토리란 뜻이다. 현재
          디렉토리에 있는 data. 보시는 것처럼 이런 결과가 나온다. 그러면 이
          얘기는 무엇이냐? 저기있는 filelist의 값은 형식을 보니까 배열이다. 즉,
          node.js는 어떤 특정 디렉토리에있는 파일의 목록을 배열로 만들고 또 err,
          filelisat로 전달하는 일종의 약속을 가지고 있다. 그러면 우리는 그
          배열을 반복문을 통해서 반복적으로 처리해서 어떠한 결과를 만들어낼 수
          있다. Node.js-24.App 제작-글목록 출력하기 우리 node.js에서 파일 목록을
          알아내는 기능을 알아보았다. 그러면 자연스럽게 이런코드를 보면 아!
          여기를 파일 목록으로 바꾸고 싶다. 아 이거를 nodejs에게 시키고 싶다.
          파일 목록을 가져온 다음에 작업이 끝나면 node.js는 function이라는
          중괄호 안에를 실행시키도록 한다. 이제 파일리스트를 가져온 것은 되었다,
          저거 그대로 안쓸거고, 저 list라는 저부분을 프로그래밍적으로 만들어주면
          된다! 그걸하기 위해서 참조하려고 가져온 것일뿐,. 이제 링크를 처리할
          것이다., else안의 코드는 id값이 있는 경우의 코드이다. 위에거를
          카피해서 붙여넣기 그리고 아무 텍스트를 넣고 리로드 해보면 node.js의
          페이지가 추가가 되었고 클릭하면 node.js의 페이지로 이동을 한다. 아주
          혁명적인 변화이다. 왜냐? 파일을 추가하면 알아서 변화가 되기 때문에
          우리는 더 이상 코드를 열어서 내용을 수정하지 않아도 된다. 우리
          프로그래머들은 데이터가 바뀌었을 때, 로직을 변경하는 것을
          부끄러워한다,. Node.js-25.3.JavaScript-함수의 출력 Sum(2, 4)는 실행이
          되지만, Marh.round(1.6)은 실행이 안된다. Math.round를 출력하려면
          console.log를 붙여야 한다. 그러면 우리가 만든 sum(2,4)는 그냥
          sum이라고하면 console.log까지 해버린다. 근데 Math.round는 귀찮게
          console.log까지 해야한다. 그러므로 우리가 만든 sum이 좋아보일 순
          있지만, 우리가 만든 sum은 융통성이 떨어진다. 왜냐? 우리가 만든 sum은
          언제나 comsole.log를 통해서 화면에 출력될 수 밖에 없다. 하지만
          Math.round는 console.log를 통해서 화면에 출력할 수도 있고 예를 들면
          이런식으로 해가지고 Math.round(1.6)의 결과를 파일에 출력할 수 있다.
          또는 이 결과를 이렇게해서 이메일로 보낼 수도 있다. 즉,
          Math.round(1.6)의 출력을 받아서 다양한 용도로 사용가능하다. 하지만
          얘는 언제나 sum이다. 그래서 우리도 여기있는 sum의 결과를 순수하게
          값으로 출력할 수 있다면, 이 결과를 훨씬더 광범위하게 응용할 수 있을
          것이다. Return을 넣어주면 이 sum함수가 실행되면 first+second가 실행된
          값, 현재는 6이겠죠? 6앞에 return이 있으므로 javascript는 여기서 이
          함수의 실행을 멈추고 그 즉시 return 뒤에 따라오는 값을 출력해주면서
          여기 있는 이부분을 6으로 만들어준다. 똑같다. 결론은 똑같지만, 우리는
          이제 이 sum이라는 함수를 이메일로도 출력할 수 있고 파일로도 출력할
          수도 있고 프린터로도 출력할 수 있다. 바로 이 return이 그런 역할이다.
          실행을 시켰더니 a가 나왔다. B는 실행이 되지 않았다. 즉, return을
          만나면 거기서 즉시, 함수의 실행은 종료됩니다! 그래서 return은 어떤
          값을 출력한다는 의미와 거기에서 함수를 종료시킨다는 두 가지의 의미를
          모두 가지고 있는 특수한 키워드이다. Node.js26.App 제작-함수를 이용해서
          정리 정돈하기 이번 시간에는 어렵게 만든 이 코드를 정리정돈 하기 위해서
          앞에서 배운 함수를 이용할 것이다. 우리가 코드가 많아지면, 기계는
          상관없는데, 사람의 입장에서는 그 복잡성이 기하급수적으로 늘어난다.
          그리고 코드를 관리하는 것이 급격히 어려워진다. 그것을 사람이 감당할 수
          있는 단순한 것으로 만들지 못한다면, 우리는 더 이상 복잡한 것에 도전할
          수 없다. 이번 시간에는 우리 코드를 함수로 정리정돈하는 것을 통해서
          함수를 어떻게 사용하는 가인 실용적인 사례를 보여줄 것이다. 두개의
          코드는 완전히 똑같다. 완전히 똑 같은 코드는 뭔가 개선의 여지가 있다.
          저렇게 title을 넣으면 Welcome이 title로 담기고 그 값이 templateHTML의
          매개변수안으로 들어가서 저기 위에 리턴되는 값안에 들어간다. 저걸
          딱보면 이전에 있었던 얘와 비교했을 때, 비교한다면, 후자는 이 로직에
          대한 설명이 없지만, 전자는 html에 대한 탬플릿인가보다라는 설명이 있다.
          전자의 함수코드를 후자의 문장에 붙여넣는다. 그리고 또 우리는 중복된
          코드가 없는지를 끝까지 쫒아가는 것이다. 똑 같은 코드이다. 저 코드가
          실행되기 위해서는 filelist라는 값이 필요한데 저 함수안에는 그 값이
          없다. 그래서 우리가 templateList가 동작하기 위해서는 저 파일리스트라고
          하는 매겨변수로 어떤 값이 입력되어야 한다. 교체가 가능하다. 이렇게
          하니까 코드가 훨씬 줄어들었고 또한 우리코드의 가독성또한 높아졌다.
          물론 여전히 중복을 제거할 수 있는 여지가 있다. 위에 코드와 아래코드
          비슷하다. 하지만 이것의 중복을 제거하기에는 까다롭다,.
          Node.js-27.수업의 정상 우리는 프로그램이 무엇이고 프로그래밍은 무엇을
          하는 일인가 또 프로그래머는 무엇을 하는 사람인가를 충분히 많이 깊게
          알아보았다. 또 우리는 Js라는 컴퓨터 언어를 이용해서 node.js의 기능을
          제어해서 웹 에플리 케이션을 만드는 구동시키는 방법을 살펴보았다. 만약
          여러분이 node.js와 JS가 이러한 기술들이 무엇이고 또 이걸로 어떻게 웹
          어플리케이션을 만드는가 바로 이러한 내용들이 필요했다면, 바로 이순간이
          강의를 마무리하고 떠나라. 그래서 지금 이후로 배우는 것들을 지금까지
          배운 것보다 훨씬 덜 중요하다. 그래서 불필요하게 더 많은 공부를 하는
          것보다 일단 현실로 돌아가서 나중에 이러한 문제가 더 많은 것을 공부해야
          될 필요성이 있다면 그 때 이곳을 찾아오셔서 다시 공부하셔도 좋을 거
          같습니다. 하지만 또 우리가 현실의 문제를 해결하다보면 코드가
          복잡해집니다. 또 처리해야될 데이터가 많아지고 우리가 만든 소프트웨어를
          많은 사람들이 사용하게 된다. 그러면 지금까지 배운 것만으로는 처리할 수
          없는 복잡하고 어려운 문제들이 생겨나게 됩니다. 바로 이러한 문제를
          해결해야하거나 또는 이러한 문제를 해결하는 일에 종사하려고 하시는
          분들은 여기서 떠나시면 안됩니다. 여러분이 어떤 상태에 있냐에 따라서
          공부를 그만두기에도 진도를 나아가기가 달려있다.
          Node.js-28.1.Nodejs에서 동기와 비동기 1 이번시간에는 노드js를 잘
          이해하기 위해서 꼭 필요한 개념이다. 바로 실크로노스와
          어싱크로노스이다. 한국어로는 동기적과 비동기적의 차이 또 의미를 이야기
          할 것이다. 왼쪽은 어느 한 일을 하고 이 일이 끝날때까지 오랫동안
          기다렸다가 일을 하는 것이 동기적으로 하는 방식이고 오른쪽은 병렬적으로
          동시에 여러가지 일을 처리하는 것이 동기적이지 않다는 뜻에서 비동기적
          처리이다. (친구나 컴퓨터에게 일을 맡겨놓고 나는 내일을 하고 친구는 또
          그일을 이어서 하고) 노드js는 비동기적 처리를 하기 위한 아주 좋은
          기능들을 가지고 있다. 지금부터 비동기 라고 하는 것을 이제 코드
          레벨에서 볼 것이다. 비동기적이라고 하는 것은 효율적이지만 매우
          복잡하다. 그렇기 때문에 노드js를 이용해서 코딩을 하는 초심자들한테
          상당히 까다롭게 느껴지는 부분이다. Node.js-28.2.Nodejs에서 동기와
          비동기 2 지금부터 동기 비동기 라는 것이 코드레벨에서 어떤 차이를 갖는
          가를 볼 것이다. 노드js공홈에서 파일을 다루는 모듈이 파일시스템이다.
          저기있네. 뭐가 되었던 간에 파일시스템에 보시면 뒤에 싱크가 붙어있는
          것과 붙어있지 않은 것들이 있다. 리드 파일 우리 해봤죠? 그리고 리드파일
          싱크가 있다. 리드파일은 패스 경로가 나오고요 옵션은 있을 수도 있고
          없을 수도 있다. 그리고 중요한 것 콜백이 있다. 그런데 리드파일 싱크는?
          패쓰가 있고 옵션이 있는데, 콜백이 없다… 그러면 이 두가지의 차이를
          통해서 동기와 비동기의 차이를 한번 보자. 이제 sync.js에서 파일리드와
          파일리드싱크를 비교해볼 것이다. Fs는 리콰이어fs를 통해서 fs모듈을
          불러와서 fs변수란 이름을 붙였다. 쟤가 실행이 된다면 sample.txt.
          안에있는 B가 실행될 것이다. 저기 B는 sample.txt.안에 있는 놈이다.
          아래는 싱크를 없에본다. 자 싱크가 있다면 동기적인 방식으로 처리하는
          명령이다. 싱크가 없으면 비동기적인 것이다. 그 얘기는 즉, 없는 것을
          선호한다는 뜻이다. 비동기적으로 처리한다는 것을 선호하고 있다는
          얘기다. 누가? 노드.js가 그러면 노드js의 문서에 보면은 3번째 자리에는
          콜백이 오도록 적혀있다. 그리고 콜백은 이런식으로 적으면된다, 자 이렇게
          한다음에, var result = 는 더 이상 이렇게 하면 안된다. 왜여?
          Readfilesync는 리턴값을 주는데, readfile은 리턴값이 아니다. 대신에
          저렇게 함수를 3번째 인자로 주어야 한다. 그러면 노드js가 이 파일을 읽는
          작업이 끝나면 우리가 3번째 인자로 준 저 함수를 노드js가 실행시키면서
          첫번재 인자에는 에러가 있다면 err을 인자로 제공하고 두번째
          파라미터에는 파일의 내용을 인자로서 주도록 약속!!!! 되어있다. 저기
          위에는 A B C가 순차적으로 실행되었다. 근데 아래것은 A C B가 나왔다.
          즉, A가 실행된 다음에 얘가 실행이 될 것인데, 그 결과를 가져오기도 전에
          바로 C가 실행이 되고 얘는 얘대로 동작하고 있다가 작업이 끝나면 저기
          있는 저 함수가 호출되면서 함수 안에 있는 이코드가 나중에 실행된
          것입니다. 자 이렇게 해서 동기적인 것과 비동기적인 것을 보았고 여러분이
          노드js의 성능을 재대로 끌어올리기 위해서는 반드시 비동기적인 방식으로
          작업을 하셔야 한다. 하지만 너무 코드가 복잡하고 내가하는 일이 그렇게
          성능이 대단한게 필요한게 아니라면, 그러면 심플한 이해하기 쉬운
          동기적인 선택을 하는 것도 잘못된 선택이 아니다.
          Node.js-28.3.JavaScript-callback 자 이번시간에는 콜백이라는 것에
          대해서 알아볼 것이다. 저것은 무슨 뜻이냐면 노드js야 니가 갖고 있는
          리드파일이라는 기능을 이용해서 이 파일을 읽어와 근데, 시간이 좀
          걸리니까 작업이 끝난다음에 내가 너한테 전달한 이 세번째 인자인 함수를
          실행시켜! 라고 얘기한 것이다. 그러면 노드js는 저 파일을 읽은 다음에,
          그 작업이 끝난후에 저렇게 전달할 함수를 호출할 거에요. 내부적으로
          상상력으로 생각해봐라. 그러면 우리가 이 작업이 끝난 다음에 처리해야 될
          일을 요거세다가 배치해놓으면 거기 있는 작업들이 처리가 될 것입니다. 자
          저것이 바로 콜백이다. 나중에 전화해! 즉, 우리가 노드js에게 파일을 읽은
          다음에 나중에 함수를 호출하는 것을 통해서 나를 불러! 이것을 실행해!
          이렇게 얘기한 것이다. 우리도 콜백을 한번 만들어보자. 콜백이 상당히
          어려운 주제지만, 이거 이해못한다고 해서 앞으로 할거 이해 못하는 거
          아니다. 그러니 심란해하지 말고 한번 두번 세번 이런식으로 이 개념에
          자신을 노출 시켜 주세요. 그러면 이해도 하기 전에 익숙해질 수 있다.
          여러분이 알고 있는 것들 중에 음, 분명히 알고 있는데 설명이 안되는 것들
          있잖아여? 이것은 익숙해진 것이다. 심란해하지 마라. 얘와 똑 같은
          코드인데 형식이 다른 것이 있다. A를 지우면? 위에 것과 다르다. 함수의
          기능, 함수의 내용은 똑같지만, 다만, 이름이 없다! 이름이 없는 함수를
          ‘익명함수’라고 한다. 근데 이름이 없으면 호출 할 수 없으므로 앞에다가
          var a = 을 해주면 위에있는 함수와 아래있는 함수가 똑같이 a라는 이름을
          갖고 있는 것이다. 그런데 밑에 있는 이 코드를 보니까 a라는 변수의
          값으로서 함수를 정의하고 있다. 그얘기는 뭐냐? Javascript에서는 함수가
          값이다! 라는 것을 의미한다. 실행하면 똑같이 나온다. 즉, 우리는 변수 a
          뒤에 함수를 호출하는 ()의 기호를 넣어주는 것을 통해서 a라는 변수가
          담고 있는 값인 함수를 실행할 수 있다. 그러면 저기에 a를 호출하는
          코드를 제거하고요. 제가 새로운 함수를 만들 것이다. Slowfunc() 굉장히
          오래 시간이 걸리는 함수가 있다고 쳐봐라, 기능이 있다고 쳐봐라 그러면
          이 기능이 이 기능에 대한 실행이 끝난 다음에, 이 기능을 실행한 쪽에게
          함수가 실행이 끝났으니까 그 다음 일을 하세요. 라고 하고 싶다면, 이
          함수가 인자로 callback를 받으면 됩니다. 그리고 이 callback를
          callback();으로 실행해주면 된다. Slowfunc();라는 함수를 실행하면서
          우리는 저기 위에 있는 a라는 변수를 여기 가져다 놓는 것이다. 그러면
          어떻게 되냐? slowfunc라는 오랜시간이 걸려서 동작하는 함수가 실행이
          되고 그러면 여기 있는 내용일거 아니에요? 그러면 이 callback이라는
          parameter(매개변수)는 어떤 값을 가지냐? a가 가리키는 저 함수을
          갖게되는 것이다. 이 안에서 callback이라는 함수를 호출하면? 어떤 결과가
          나오냐? 쟤가 실행될 것이다. 실행하고 나니까 A가 나온다, 바로 이것이
          callback이다 ---- createServer는 nodejs로 웹브라우저가 접속이
          들어올때마다 CreateServer의 콜백함수를 nodejs가 실행시킨다. Callback
          Function = function(req, res){} 그리고 만약100이라는 데이터가 있으면
          그 중에서 조각조각의 양들을 수신할때마다, 서버는 function(data) {} 아
          콜백함수를 호출하도록 약속되어 있다. 그리고 그것을 호출할 때,
          데이터라는 인자를 통해서 수신한 정보를 주기로 약속하고 있다. ---- 라는
          뜻이다! Node.js-30.HTML-form 웹브라우저에서 서버로 데이터를 전송할 때
          사용하는 기능이 form입니다. 여기서는 HTML로 폼을 만드는 방법을
          살펴보겠습니다. 자 지금까지 우리가 만든 웹 애플리케이션은 데이터
          디렉토리에 파일을 생성하면 그 파일을 감지해서 글 목록을 만들어주고 또
          우리 대신에 html코드를 생성해주는 웹 에플리케이션을 우리는 만들 수
          있게 되었습니다. 엄청난 변화이다. 자 그런데 이렇게 하다가 보니까, 어떤
          문제가 발생하냐면, 데이터 디렉토리에 접근할 수 있는 것은 자기
          자신뿐이기 때문에, 컨텐츠를 생성하는 것은 이 사이트의 소유자만이 할 수
          있다. 이런 한계가 있다. 우리가 어떤 꿈을 꾸게되냐? 누구나 웹을 통해서
          데이터를 전송하면 그 전송한 데이터를 데이터 디렉토리 안에 생성하고
          싶다라는 생각을 하겠다. 지금부터 우리가 살펴볼 것은 컨텐츠를 사용자가
          웹을 통해서 생성하고 또 수정하고 삭제하는 방법을 이제부터 쭉 길게
          살펴볼 것이다. 그 첫걸음으로서 먼저 볼 것은 사용자가 서버쪽으로
          데이터를 전송하기 위한 방식인 html의 form이라는 기능을 볼 것이다.
          Input은 한줄 textarea는 여러줄. 자그럼 사용자가 입력한 정보를 서버로
          전송하기 위해서는 저 정보를 어디로 보낼 것인가에 대한 주소가 필요하다.
          여기 입력한 정보를 서버로 이 주소로 전송하고 싶다라는 뜻이다. 근데 저
          네모박스에게 입력한 각각의 값들이 이름이 있어야지만 서버쪽에서 받았을
          때, 의미가 있다. 둘다 무엇인가를 치고 제출을 누르면 이 생성된다. 즉,
          쿼리스트링이 만들어지는 것을 볼 수 있다. 그래서 이 form이라고 하는 저
          테그는 그 폼안에 있는 각각의 컨트롤들에 사용자가 입력한 정보를
          submit버튼을 눌렀을 때, action속성이 가르키는 서버로 쿼리스트링의
          형태로 데이터를 전송하는 기능이다. Html의 기능!!1이다. 우리는 아직
          process_create가 없기 때문에 not found가 떴지만, 저 애플리케이션에게
          title과 description값을 전송하기는 했는데, 이건 좋은 방법이 아니다.
          우리가 특정 웹페이지를 사용자가 가져갈 때, id는 html했는데 이건 좋은
          방법이다. 왜냐? 이렇게 주소상에 우리가 필요한 데이터가 포함이 되어
          있어야지만, 이걸 카피해서 누군가한테 전송해도 그 사람이 그걸 클릭해서
          여기로 올 수 있기 때문이다. 자 그런데, 우리가 할려고하는건 글을 쓰는
          것이고 그리고 뒤에서는 글을 수정하고 삭제하는 일도 할 것이다. 근데,
          그걸하기위해서 데이터를 전송할 때, 주소에 데이터가 포함이되어 있다면,
          저 주소를 무심코 카피해서 누군가한테 보내게 되었을대, 그 사람이 그거를
          클릭해서 들어오면 우리 서버에 있는 정보가 수정되거나 삭제되거나
          생성되는 사건이 일어날 수 있다. 그렇기 때문에 서버에서 데이터를
          가져올때는 즉, get할때는 ?는 머머머 이런 쿼리스트링을 쓰고요 서버에
          데이터를 생성하거나 수정하거나 삭제하는 수정행위를 가핼때는 필요한
          데이터를 이렇게 url로 보내면 절대 안된다. 그러면 어떻게 해야하나? 눈에
          보이지 않는 방식으로 보내야 한다. 그러면 그 방법을 메소드 Post로
          하시면 된다. url에 쿼리스트링은 보이지 않는다. 그렇다면 어디 갔냐?
          사람눈에 보이지 않는 방식으로 은밀하게 서버로 전송한 것이다. 자 이렇게
          전송하면 아주 큰 데이터도 전송 할 수 있다. 반면에 url로 데이터를
          전송할때는, url은 무한히 긴 데이터를 수용하지 않기 때문에, 나중에
          데이터가 짤릴 수도 있는 문제가 있다. 그래서 여러분이 그 서버로부터
          사용자가 데이터를 가져올때는 get할때는 get방식을 쓴다. Get 방식은
          method=”get”라고 적혀있거나 또는 메소드가 생략되어있을 때, get이다.
          하지만 서버의 데이터를 수정 삭제 생성과 같은 것을 할때는 반드시
          method=”post”로 해야한다. Node.js-31.App 제작-글생성 UI 만들기 아직
          procress_create는 아직 처리가 안되어서 404가 떴다. 헤더를 보시면
          form데이터의 타이틀과 디스크립션이 포스트방식으로 은밀하게 전송된 것을
          볼 수 있다. 우리는 이제 사용자가 전송한 데이터를 받는 node.js쪽 페이지
          process_create 페이지를 만드는 것이다. Node.js-32.App 제작-POST
          방식으로 전송된 데이터 받기 굉장히 어려운 주제를 만났을 때, 이해하려고
          하지 말고 그냥 그려러니 그냥 저렇게 코드를 써서 쓰면 되는구나라고
          생각하면 쉽게 넘어갈 수 있고 자꾸쓰다보면 익숙해진다. 나중에 여러분이
          충분히 익숙해졌을 때, 걔를 이해할 수 있는 순간이 올 것이다. 검색,
          nodejs post data 검색 저거는 전송되는 정보의 크기가 너무 크다면 접속을
          끊어버리는 일종의 보안 장치이다. 즉, 우리는 이 데이터와 end같은 것들을
          이벤트라고 하는데, 저걸 이용해서 웹 브라우저로부터 post방식으로 전송된
          데이터를 가져올 수 있고 또 qs.parse라는 함수를 통해서 정보를 정확하게
          객체화 할 수 있다. Node.js-33.App 제작-파일생성과 리다이렉션 이번에는
          포스트방식으로 전송된 데이터를 데이터 디렉토리안에 파일의 형식으로
          저장하는 방법을 알아볼 것이다. 검색 nodejs file write 공식문서 저기에
          콜백함수가 실행이 된다는 것은 파일의 저장이 끝났다는 뜻이고 파일의
          저장이 끝난다음에 success를해줘야 하니까 저 코드는 저기에 있으면
          안되고 쟤를 안쪽으로 옮겨줘야 한다. 사용자가 어떤 페이지로 왔고 어떤
          처리를 하고 그리고 처리가 끝난후에 사용자를 다른 페이지로 튕겨버리는
          것! 그것을 리다이렉션이라고 한다. 검색 nodejs redirection 301은
          사용자를 다른데로 보내긴 하는데, 이런 뜻이다. 이 주소는 이 주소로
          영원히 바뀌었습니다. 앞으로 이런곳으로 오세요. 하지만 우리는 이런 것이
          아니고 일시적으로 영원히 바뀐 것이 아니라! 200은 성공했다는 뜻이고
          302는 페이지를 다른 곳으로 리다이렉션시키라느 뜻이다. 우리는 지금까지
          사용자가 입력한 정보를 받아서 다이나믹하게 프로그래밍적으로
          데이터디렉토리에 파일을 생성하는 법을 알아보았다. Node.js-34.App
          제작-글수정-수정링크생성 우리가 업데이트를 할때는 누구를 수정할건지에
          대한 정보가 필요하고 그것을 쿼리스트링의 형태로 전달할 것이다.
          Node.js-35.App 제작-글수정-수정할 정보 전송 저부분은 지우는게 좋다.
          만약 우리가 도메인을 달거나 그러면 동작을 안할거니까여. 그래서
          사용자가 수정하는 정보와 우리가 수정하고자하는 정보를 파일을 구분해서
          전송해야한다. Node.js-36.App 제작-글수정-파일명 변경, 내용저장 사실
          여기서부터 하는 것은 스스로 고민해서 끝낼 수 있는 부분이다. 너무
          힘들면 유보하거나 조금 쉬었다가 해라. 여러분 확인을 자주해야한다. 사실
          에러처리를 잘 해야하는데, 지금은 에러처리를 하고 있지 않다. 파일을
          수정하고 그 후에 파일 내용을 바꾸면 된다. Node.js-37.App
          제작-글삭제-삭제버튼 구현 한가지 조심해야 할 것이 있다. 이 업데이트를
          클릭하면 업데이트 페이지로 간다. 델리트를 클릭하면 어디로 가지 않고
          바로 삭제를 하고 싶다. 그런 경우에 삭제 버튼을 링크로 만들면 대단히
          잘못된다. 즉, 삭제할때, 링크를 보낸다. 생성할떄도 마찬가지였지만,
          삭제라고 하는 수정을 가하는 것이기 때문에, 지울때도 절대 링크로 하시면
          안된다. 즉, form으로 해라. 저기 delete저거 create와 update와 똑같이
          만들 수 있다. 저기 온서브밋을 넣어서 데이터를 전송하기 전에 다시한번
          물어보도록 할 수 있는 기능을 만들 수 있다. Node.js-38.App 제작-글삭제
          기능 완성 Nodejs delete file 검색 우리는 정말 많은 것을 했다. CRUD라는
          정보기술의 핵심적인 기능 4가지를 배웠다. Node.js-39.JavaScript 객체의
          형식 Node.js-40.JavaScript-객체-반복 객체의 반복 in앞에 있는
          name이라고 하는 변수에는 위에 객체의 식별자 ‘키’가 들어오도록 약속되어
          있다. 우리가 value를 얻고 싶다면, var roles = { 'programmer':'egoing',
          'designer' : 'k8805', 'manager' : 'hoya' }
          console.log(roles.designer); //k8805 console.log(roles['designer']);
          //k8805 for(var n in roles){ console.log('object => ', n, 'value => ',
          roles[n]); } Node.js-41.JavaScript-객체-값으로서 함수 ‘객체 지향
          프로그래밍’이란 기능을 볼 것이다. 이번 시간에는 객체지향과 관련해서
          여러분들이 좀 갖고 계시면 덜 고통스럽게 객체지향을 시작할 수 있는
          몇가지 이미지와 몇가지 코딩방법들을 설명해드리도록 할 것이다. 우리가
          프로그래밍을 한다는 것은 크게 두가지로 이루어져 있다. 첫번째는 데이터,
          두번째는 그 데이터를 처리하는 것. 이 두가지로 이루어져 있다고 해도
          과언이 아니다. 데이터를 사용하기 좋게 복잡하지 않게 잘 정리정돈하는
          도구는 뭐가 있었냐? 배열과 객체가 있었다. 그리고 JS에서 어떤 처리하는
          코드가 많아지면 서로 연관된 것들을 그룹핑하기 위해서 우리는 함수를
          쓴다. 이 두가지의 처리방법인 코드가 서로 연관되어 있고 다른 코드들과
          구분하기 위해서 우리는 서로 연관된 처리방법들에 이름을 붙이고 다른
          것들과 구분할 수 있게 한다. 그러나 자바스크립트에서는 저 함수라는
          친구가 굉장히 독특한 특성을 가지고 있다. 함수는 처리해야될 일에 대한
          어떠한 정보를 담고있는 일종의 구문! 영어로는 statment라고 할 수
          있으면서 동시에 값!이다. 값이라는 것을 쉽게 확인할 수 있는 점은, 저
          함수를 변수에 넣을 수 있다면 저것은 값이다. 그런데 넣을 수 없다면 걔는
          값이 아니라고 생각해라. 에러가난다. 왜냐하면 JS에서는 저 조건문이라는
          구문이 값이 아니기 때문이다. 실행해보니 에러가 난다. 즉, while이라는
          statement는 값이 될 수 없다. 그렇다면 f1은 값이 될 수 있을까? 일단
          F1의 이름을 지웠고 이름이 없는 함수이니 익명함수가 되었다. 에러가 나지
          않는다. 그리고 Console.log(f)하면 f가 출력이 된다. 그리고 f();하면 f는
          실행됩니다! 즉, JS에서는 저 function이라고 하는 statement가 if와 같이,
          다른 statment와는 다르게 값이 될 수 있다. 즉, 처리방법들을 담고있는
          구문이면서 동시에 그것 자체가 값이 될 수 있다., 라는 것이 우리가
          주목해야 될 특징이다. 지금 배열에 f라는 원소가 담기었는데, 저 원소는
          함수이다! A[0]은 f이고 f는 함수이며 거기에 f()으로 실행했으므로 값이
          출력된다, 즉, 배열에 원소로서 함수가 존재할 수 있다. o라고 하는 객체에
          함수를 담는다. o.func(); 할때, func는 f이고 f는 위에 함수이므로
          실행시키면 2,3 이 나왔고 그 이유는 쟤가 실행된 결과이다,. 즉, JS에서
          배열과 객체는 모두 서로 연관된 데이터를 담는 그릇인데, Js에서는
          처리방법을 그룹핑하는 함수조차도! 데이터이기도 하기 때문에, 우리는
          배열과 객체에다가 담을 수 있다, Node.js-42.JavaScript-객체-데이터와
          처리 방법을 담는 그릇으로서 객체 이번시간에서 JS에서 함수는 값이기
          하기에 배열과 객체에 담을 수도 있다. 허나 값으로서 배열에 담는 경우는
          많지 않다. 쓸모가 없기 때문에! 하지만 객체에는 많이 담는다. 왜냐?
          객체에는 이름이 있기 때문이다. func처럼. 즉, 우리가 담아 논 함수를
          이름으로 꺼낼 수 있다. 그래서 이 객체에 함수를 담는 것을 통해서 우리가
          무엇을 할 수 있는지 어떤 점을 할 수 있는지 알아보자. 지금 우리가 쓰고
          있는 object.js가 1억줄 짜리 코드하고 상상해보자. 그리고 프로젝트를 한
          20년 동안 진행하고 있고 프로젝트에 참여하는 2000명이라면, 이것은
          지옥이다. 이렇게 되면 일어날 수 있는 모든 문제가 일어난다. 그렇다면
          1억줄에 수많은 변수가 있을텐데, 그중에 하나! 일단 아무런 실용성이
          없다. 저는 여러분에게 컨셉, 실용성을 알려드리는 것이기 때문이다.
          상상력으로 실용적이라고 믿어라 v1과 v2가 묶여져 있지 않고, 그 사이에
          수 많은 코드가 있고 또 어떤 다른 사람이 v1을 이제 egoing이라는 문자로
          지정하게 된다면 엉뚱한 상황이 되고 버그가 일어나고 코드가 ㅈㄴ 많으면
          버그찾기가 ㅈㄴ 힘들다. 바로 이러한 상황에서 우리를 구원해 줄 수 있는
          도구가 바로 객체이다. 이런 식으로 서로 연관된 값들을 하나의 객체안에
          정리정돈해서 넣어 둘 수 있게 된다. 이것은 마치 하나의 하드디스크에
          1억개의 파일 몰아넣은 상황이었던 것이 폴더라는 기능이 만들어지면서 그
          폴더로 파일을 정리정돈 하는 상황이 된 것이다, 우리가 프로그래밍을
          하다가 보면 저런 데이터만 필요한 것이 아니라, 데이터를 처리하는 과정도
          필요하다. 그런데 1억줄 짜리 코드이이다. 그런데 어느 신입 엔지니어가
          들어와서 여기 이 1억개의 코드 안에서 F1이라는 이름으로 엉뚱한 용도로
          자기가 필요해서 만들었다고 생각해보자. 그러면 우리가 만든 f1이라는
          함수가 삭제된 것이나 다름 없다. 이런 경우가 있다. 이러한 경우에 우리를
          구원해주는 도구가 객체이다. JS에서는 함수가 값이다라고하는 특성을
          이용하면, 이 함수를, 이 함수가 사용하고 있는 데이터들이 그룹핑 되어
          있는 객체에 멤버로서 추가할 수 있다. 자 보시면 아까와 똑같이
          동작하지만, 우리의 코드는 훨씬 더 잘 정리정돈 되어 있다. 왜요? o라고
          하는 하나의 객체 안에 서로 연관된 값들과 그 값을 처리하는 함수들이
          그룹핑되어 있기 때문이다. 그런데, 우리가 만든 코드는 조금 웃긴 면이
          있다. 저 함수안에 있는 코드를 보면은 저 함수가 속해있는 이 객체가 어떤
          이름의 변수에 할당 될 것인지를 저 함수가 알고 있어야 한다. 만약 p로
          객체의 이름을 설정했다면 동작하지 않을 것이다. 왜요? 저기 위에 객체는
          p라고 하는 이름을 가진 객체인데, 당연히 이제 o라고 하는 객체는
          존재하지 않기 때문입니다. 그래서 JS를 만든 사람들은 함수가 객체 안에서
          사용될 때, 그 함수가 자신이 속해있는 객체를 참조할 수 있는 특수한 어떤
          약속이 필요하기 떄문에 라고 하는 것을 알아내고 this라고 하는 약속된
          키워드를 만들어 낸다. 그러면 우리가 만든 저 객체가 어떠한 이름의
          변수에 담기는 것과는 상관없이 우리는 언제나 함수 내에서 this라고 하는
          약속된 값을 통해서 그 함수가 속해있는 개체를 참조할 수 있게 된다.
          그리고 거기에 v1이 있는 것이다. 이러면 잘 동작한다. 여전히 잘
          동작한다. 자 그래서 이번시간에 우리가 살펴본 것은 함수가 값이다.
          그리고 객체는 값을 저장하는 그릇이다라고 하는 특성을 이용해서 서로
          연관된 데이터와 또한 서로 연관된 처리방법들을 담고있는 함수들을 저렇게
          그룹핑하는 것을 통해서 우리는 코드의 복잡성을 획기적으로 낮출 수
          있다느 것을 살펴보았다. 자 이것이 여러분들이 객체지향을 바라보는
          첫번째 어떤 느낌이 되었으면 좋겠다. 객체가 현실에서는 아주아주
          복잡하지만, 하지만 결론적으로 객체라고 하는 것이 결국에는 코드가
          복잡해짐에 따라서 그 코드를 정리정돈해서 코드의 복잡성을 낮추는
          기본적인 기능으로부터 출발한다라고 하는 것을 여러분이 분명하게
          인식하고 있다면 그 외의 등장하는 여러가지 기능성들은 여러분들에게 되게
          지적인 어떤 짜릿한 쾌감을 줄 것이다. 그런데 그 본질을 모른다면 굉장히
          고생할 것이다. func저거는 객체의 원소, 저는 property라고 한다.
          Node.js43.App제작-템플릿 기능 정리정돈하기 객체가 무엇이냐? 객체란
          서로 연관된 데이터와 그 데이터를 처리하는 방법인 함수를 그룹핑해서
          코드의 복잡성을 낮추는 수납상자이다. 우리가 보통 함수의 이름을 지을
          때, 이름에 접두사 접미사에 같은 이름을 쓰는 이유는 서로 성격이 같은
          것들을 그룹핑하기 위해서 이름을 쓴다. 그래서 이름보다도 우리가 객체를
          통해서 우리가 이것들을 정리정돈 할 수 있다면 훨씬더 우아하게 만들 수
          있다. 코드가 기하급수적으로 늘어나서 코드의 복잡성이 높아진다면 이러한
          테크닉들은 필수이다. 리팩토링이 굉장히 중요하다. 우리가 처음부터
          함수와 같은 것들을 이용해서 코드를 짜는 것은 쉬운 일이 아니다. 이걸 할
          수 있다는 것은, 객체 같은 것을 써서, 정말 초고수이다. 여러분이 알고
          있는 최소한의 문법으로 좀 투박하고 좀 불편하지만, 어쨌든간에 잘
          동작하는 코드를 짠다음에, 여러분이 자주자주 리팩토링을 해줘야 한다.
          즉, 짤때는 몰랐는데, 나중에 한발짝 물러나서 옛날에 짰던 코드들을 보면
          그 안에 반복되는 패턴들이 보인다. 그 패턴들을 함수화 시키고 또 객체화
          시키고 또 배열화 시키고 이런 과정을 통해서, 여러분이 코드를 훨씬 더
          유지보수가 쉬운 코드로 개선시켜나가는 과정을 천천히 가면 된다.
          처음부터 이상적인 코드를 짜려고 하면 한 줄도 짤 수가 없다. 또 내가
          하는 코딩이 즐겁지 않고 내가 만든 결과물이 부끄러울 수 있다. 이렇게
          해선 생산자가 되기 어렵다. Node.js-44.Node.js 모듈의형식 이번시간에
          모듈을 알아볼 것이다. 우리가 코드를 작성하는 과정에서 코드가 늘어나면,
          그것을 잘 정리정돈할 필요성이 생긴다. 그 과정에서 등장하는 주인공들,
          배열 객체 함수 이런 것들이 있다. 그러면 이러한 것들의 끝판왕인 객체가
          많아지면 그 객체를 또 정리정돈 할 수 있는 더 큰 틀의 정리정돈도구가
          있지 않을까요? 그게 바로 모듈이고 모듈이 가장 큰 정리정돈 도구하고 할
          수 있다. 그러면 모듈이 무엇인가를 코드레벨에서 볼 것이다. 저렇게
          객체가 있는데, 객체가들이 많아지면 정신 산만해진다. 그러면 다시 우리는
          정리정돈을 할 필요가 생긴다. 그러면 많은 객체, 많은 함수도 마찬가지,
          를 정리정돈 할 수 있는 더 큰 틀의 도구가 모듈인데, 우리가 모듈을
          이용하면 이러한 것들을 파일로쪼개서 외부로 독립시킬 수 있다. 다른
          파일을 만들어서 저기에 저렇게 해놓고 module.exports라고 한다. 이거는
          약속이다. 이거는 무슨 뜻이냐면, 우리가 지금 만들고 있는 모듈이
          담겨있는 mpart.js라는 저 파일에 있는 여러 기능들이 있을 수 있는데, 그
          기능들 전체가 아니라, 그 기능들 중에서 이 M이 가리키는 저 객체를 이
          모듈밖에서 사용할 수 있도록 exports하겠다! 이정도로 이해해라. 모듈을
          가져오는 것은 require이다. 그리고 가져오는 모듈의 파일이 같은
          디렉토리에 있기 때문에 ./ 현재 디렉토리라는 뜻이고, ./mpart.js 라고
          써주고 어떤 것이 있는지 확인해보니 저렇게 결과가 나왔다. 즉, part라는
          변수는 저 모듈을 로딩한 결과를 part에 담았는데, part에는 저렇게 생긴
          객체가 들어있고 저 객체는 우리가 module.exports의 값으로 입력한
          M객체라는 것을 알 수 있다. 이렇게 하면 똑같이 동작한다. 이것이 바로
          모듈이다. 물론 모듈을 여러분들이 사용하는 좀 더 복잡하고 다양한
          테크닉들이 있지만 그것은 나중에 맥락적으로 알아보면 될 것이다. 즉,
          part는 모듈로 연결시킨 객체를 나타낸다. Node.js-45.App 제작 - 모듈의
          활용 코드가 복잡해지면 저런 것들도 모듈로 쪼개서 잘 관리할 수 있다.
          Node.js-48. API와 CreateServer 이번시간에는 매우 중요한 단어의 의미를
          알아보겠습니다. 바로 API입니다. 우리가 만들고 있는 웹 애플리케이션은,
          nodejs가 갖고있는 기능들을 호출함으로써 동작하게 됩니다. 이미 익숙한
          저 함수에 대해서 생각하자. 저 함수는 누가 만들었는가? 내가 만들었나?
          아니다. Nodejs를 만든 개발자들이 만든 것이다. 여러분은 이 함수가 어떤
          원리로 동작하는지 모른다. 노드js를 만든 개발자들은 노드js를 이용하는
          개발자들에게 파일을 읽을때는, readfile를 사용하라고 사용 설명서를
          통해서 말하고 있습니다. 즉, readfile이라는 함수의 이름과 거기에
          들어가는 parameter 그리고 리턴값은. 이 함수를 만드는 nodejs를 만든
          개발자들과 이 함수를 사용하는 노드js를 이용하는 개발자들의 약속된
          조작장치입니다. 이러한 조작장치를 Interface라고 한다. 즉, 우리는
          readfile이라는 함수, 다시말해서 Interface를 실행시킴으로써
          애플리케이션을 만들 수 있게되는 것입니다. 이렇게 애플리케이션을
          프로그래밍하기 위해서 제공되는 Interface를 API라고 합니다. 이제
          여러분은 어떤 프로그래밍 언어를 만나든간에, 그 언어가 가지고 있는
          조작장치들이 궁금하다면 API를 찾거나 검색하는 것을 통해서 문제를
          해결할 수 있는 준비가 완전히 끝난 것이다. 이번시간에는 노드js의
          API문서를 한번 살펴보면서 우리가 바라보는 또 우리의 시야가 얼마나
          넓어졌는지를 한번 살펴보도록 하자. 즉 각각의 버전 별로 어떠한 기능들을
          마련하고 있는가 라는 것을 보여주는 문서라는 뜻이다. 클릭해서 들어가면
          그 해당버전에서 제공하는 모듈들이 나온다. 우리 이미 모듈을 어떻게
          만드는지 안다. 그리고 그 모듈 안으로 들어가보면, http한번 들어가
          볼까요? 그러면 이 http라고하는 모듈이 갖고 있는 여러가지 기능들 예
          기능들이 나오고 있습니다. 그중에서 우리 HTTP라고 하는 것으로 들어가
          볼까여? 자 HTTP는 웹서버와 웹브라우저가 서로 통신할 때, 사용하는
          통신규칙이고 바로 그 통신을 지원하는 노드js의 기능들이 여기에 있는
          것입니다. 아직까지 이 코드에서 구체적으로 설명하지 않았던 부분을
          설명하는 것으로 우리 수업의 대단원의 막을 내릴 것이다. 저기 위에 보면
          우리가 http라고 하는 모듈을 우리가 가져오고 있다. 그리고
          createServer라고 되어있는데, 즉, API문서에 http라고 하는 모듈!, 이면서
          쟤는 객체이기도 하다. 이것은 createServer라고 하는 함수가 있는데,
          함수가 객체안에 있을때는 메소드!, 암튼 있는데, 첫번째 인자로는
          requestListener라고하는 parameter가 있고 거기에 인자는 있을 수도 있고
          없을 수도 있다는 것이 여기 있는 대괄호의 의미이다., 생략가능하다.
          그리고 requestListener를 보면 뭐라고 써 있어여? 함수이다! 라고
          적혀있고 그렇기 때문에 우리가 createserver의 첫번째 인자로 이렇게
          엄청나게 긴 함수를 적어준 것이다. 우리는 createserver라는 함수를
          이용해서 이 함수의 이름에 적혀있는 것처럼 웹서버를 만드는 것이다.
          그리고 이 웹서버로 외부에서 요청이 들어올때마다 웹서버는 이 첫번째
          인자에 해당되는 저 함수를 호출하면서 그 함수의 첫번째 parameter로는
          웹브라우저로부터 들어오는 요청에 대한 여러가지 정보를 담고있는 객체인
          request라고 하는 것을 인자로 주기로 약속되어 있고 그리고 두번째
          parameter값(response)의 값으로는 여러분이 여기있는 이 함수 안에 구현을
          통해서 사용자에게 전송하고 싶은 정보, 예를 들면 이런거죠? 이것의
          처리가 성공했는지, 파일을 찾을 수 없는지 이러한 코드 값 또 그 실제
          내용, 이러한 정보를 response를 통해서 여러분이 응답할 수 있도록
          response라고 하는 객체를 넘겨주고 있는 것이다. 그러면 여러분은 그
          약속에 따라서 요청한 정보와 여러분이 응답할 정보를 잘 버무려서 웹
          애플리케이션을 만들게 되는 것입니다. 자 그리고 createserver라는 것은
          리턴 값으로 http.server라는 것을 반환하고 있거든요? 그래서 여기 있는
          코드를 보면 저기 app이라고 하는 저 변수에 http.sever라고 하는 것이,
          객체라고 생각해라. 객체가 담겨있는 것이죠. 자 그러면 http.server라고
          하는 api는 어떻게 생겼는지 보자. 밑에 코드에 app.listen이라고 있고
          왼쪽에도 listen이 있다. Listen이 무엇인지가 이렇게 매뉴얼에 적혀
          있는데, 즉, 요청에 대해서 응답할 수 있도록 httpserver를 구동시키는
          API가 listen이다. 그리고 listen이라는 api는 server.listen 이라고 하는
          여기있는 net.server라고 하는 또 다른 모듈과 똑 같은 것이다라고
          적혀있어서 들어가보면 Possible signatures 라고 되어 있는데,
          signatures는 그 함수의 형태이다. 이름 이라든지. 인자라든지,
          리턴이라든지, 이런 형식들을 시그니처라고 한다. 여기 보면 여러가지
          형태가 있는데, 그중에 하나! 첫번째 자리에 포트가 들어오고
          생략가능하다고 나와있다. 즉, 우리는 마지막 시그니처를 쓰고 있다.
          3000번이라고 하는 포트를 쓰고이다. 그래서 우리가 3000번이라고 여기에
          적어주면 우리가 만든 웹서버는 리스닝을 시작할 때, 3000번 포트를
          바로보고 있다! 3000번 포트에 귀기울이고 있다가, 웹브라우저로부터
          접속이 들어올 때, 3000번 포트로 들어오면 바로 우리가 만든 이
          애플리케이션이 그것에 응답해서 동작하게 되는 것이다. 자 이렇게 해서
          의문에 쌓여 있던 createserver라고 하는 api가 뭔지 살펴보았고 그것 보다
          더 중요한 주제, 과연 api란 말의 의미가 무엇인가라는 것도 같이
          생각했다. 자 이렇게 해서 우리 수업의 내용은 여기까지 이다.
          Node.js-49.수업을마치며 /* node.js 의 장점은 그동안 javascript 언어를
          이용해서 '브라우저'만 컨트롤했다면 이제는 컴퓨터자체를 컨트롤을 할 수
          있다는 것에 가장 큰 장점이있어요. (왜냐하면, 새로운 프로그래밍언어를
          배울필요없이 친숙한 javascript를 기반으로하기 때문이죠) 물론
          javascript 언어는 브라우저를 컨트롤하기위해 태어났지만 천재남자가
          'node.js' 라는 것을 만들면서 사람들은 이미알고있는 javascript를 가지고
          서버컴퓨터를 컨트롤할 수 있었던 것이죠. (매우 놀라움) 다시 돌아와서
          node.js는 서버와 데이터베이스에 관련된 것이며, 질문주신 html을 왜
          저렇게 변수에 담아서 표현하느냐? 라는 질문에는 '강의할때 한페이지에
          이해시켜주고자 저렇게 변수에 담은 것' 이다 라고 답을 할 수
          있을것같아요. 물론! 실제 프로젝트에 참여해보시면 질문해주신것처럼
          html페이지를 분할해서 필요한 섹션들을 가져와서 마치 레고를 조립하듯이
          만들긴 합니다. (이런방식이 node.js 만 그런것이 아니에요! ㅎㅎ) 더
          나아가서 html/css/js 문서만으로도 프론트가 구현가능하지만 이것은
          매~~~우 번거롭고 힘들고 수많은 기능들을 사용하지 못하게 됩니다.
          (개발자들이 편하게 api를 만들어놓는데 안쓸이유는 없잖아요? ㅎㅎ)
          그래서 프론트 프레임워크 react, vue.js 가 있죠! 결론, node.js =
          백엔드(서버와 DB를 관리하며 요청이들어온 데이터를 가공해서
          클라이언트로 넘겨준다.) react, vue.js = 프론트엔드(서버에서 받은
          가공된 데이터를 화면에 뿌려준다.) */ 지금까지 우리는 JS의 기능과
          Node.js의 기능을 이용해서 웹 애플리케이션을 만드는 방법을 살펴보았다.
          이것은 현대적인 웹 애플리케이션을 위한 필수적인 요소이면서 더 나아가서
          인터넷에 대한 동작원리를 알게 된 것이다. 더 많은 것을 공부하기 전에
          충분히 기뻐해라!!!! 이걸 생략하면 우리의 뇌는 공부를 싫어하게 된다.
          노드 js의 인터페이스는 JS의 문법으로 만들어져 있다. JS는 원래
          웹브라우저를 프로그래밍적으로 제어하기 위해서 고안된 언어이다.
          노드js를 통해서 JS를 처음 접했다면 JS의 고향인 웹브라우저를 JS로
          제어하는 방법에 도전해봐라. 그러면 여러분은 사용자에게 보여지는
          클라이언트쪽 부분과 서버내에서 데이터를 처리하는 서버측 부분 모두를
          하나의 단일언어인 자바스크립트로 구현하게 된다. 이렇게 하는 것은
          효용은 또 있다. 만약에 JS를 노드js를 통해서 처음 만났다면, 그 사람은
          노드js와 js가 하나 인 것처럼 여기게 될 것이다. 하지만 JS를 이용하는
          서로 다른 시스템, 예를 들면 웹브라우저와 노드js를 경험해본다면
          자바스크립트와 자바스크립트가 아닌 부분을 보다 절도있게 구분할 수 있게
          된다. 그렇게 된다면 오늘날 쏟아지고 있는 JS로 제어할 수 있는
          여러시스템들을 매우 빠르게 공부해서 심도있게 제어할 수 있는 실력을
          갖추게 될 것이다. 그리고 또 우리가 공부해볼만한 것은 db이다. 우리는
          정보를 데이터라는 디렉토리에 파일의 형태로 저장하고 있습니다. 파일은
          쉽고 어디에나 있다. 파일의 장점이다. 하지만 파일은 불편하고 위험하고
          느립니다. 파일의 단점이다. 파일을 이용해서 안전하면서도 빠르게 하려면
          그것 자체로 인생을 갈아넣어도 될까 말까한 굉장히 어려운 일이다. 바로
          이렇게 어려운 일을 위해서 천재가 만든 것이 파일의 대체제인
          데이터베이스이다. 여러분이 데이터 베이스를 도입하면 데이터 디렉토리에
          저장했던 정보를 데이터베이스라고 하는 전문화된 프로그램에 저장하게
          된다. 그렇게 되면 우리의 웹은 데이터베이스가 가진 엄청난 성능과 보안과
          편리함을 거져먹는 애플리케이션으로 탈피할 수 있게 됩니다. 노드js와
          함께 자주 사용되는 DB는 2018년 현 시점에서는 또 공부해볼만한 매우
          중요한 주제가 프레임워크입니다. 각 분야별로 소프트웨어들은 공통적인
          부분과 공통적이지 않은 부분이 공존한다. 예를 들어서 웹 애플리케이션을
          만드는 경우에 사용자의 요청을 처리하는 것, 또 인증하는 것, 또 보안을
          철저히 하는 것, 또 파일을 서비스 하는 것과 같은 것들은 공통적인 것이고
          어디에나 사용되는 것이다. 이렇게 공통적인 요소를 미리 구현해 놓은 것을
          프레임워크라고 일단 생각하자. 프레임워크를 이용하면 여러분이 자신이
          하고자하는 일에 특화된 부분에 집중할 수 있게 됩니다. 하지만
          프레임워크를 다루기 위해서는 많은 공부를 해야한다. 자 무엇보다도
          중요한 것은 노드js가 어떠한 기본적인 모듈을 가지고 있는가? 그리고 이
          노드js생태계가 만들고 있는 쉽게 예기해서 npm과 같은 패키지 매니저를
          이용해서 여러분이 설치해서 쓸 수 있는 모듈들이 어떤 것이 있는가를
          풍부하게 파악하는 것입니다. 어썸 할만한 여러 라이브러리들을 모아논
          일종의 북마크들을 최근에 많이 만들고 있고 그런 것들을 어썸이라고 한다.
          위와같이 검색하면 여러 결과를 얻을 수 있을 것이다. 이런 것들을
          이용해서 주목받는 모듈들의 목록을 종종 살펴보아라. 여러분이 알고있는
          모듈이 많을수록, 해낼 수 있는 일도 많아집니다. 이제 더많은 것들을
          배우고 싶다는 충동이 생길 때, 호기심 기대감이 있어야 한다. 불안감
          초초함이라는 상태라면 진도를 나가지 말고 지금까지 우리가 짠 코드를
          보고 다시 짜보자. 그리고 안보고도 짜보고 혼자서 설명해보고 남들에게
          설명해보면서 자꾸 우리의 뇌에 우리가 지금까지 작성한 코드를
          로드시켜보겠습니다. 이 과정을 반복하다가 보면 어느순간 폭발적으로
          진도를 뺼 수 있는 시간이 와요. 그때가 진도를 나가기 아주 좋은
          타이밍이다.
        </p>
      </div>
    </div>

    <div id="box">
      <div id="button">
        <input
          style="font-size: 25px"
          type="button"
          value="night"
          onclick="night_day_control(this)"
        />
      </div>
    </div>
  </body>
</html>
